(**************************************************** IntegrityLevels: Created by S-K Chin, 17 January 2011* Based on SecurityLevels created on 3/1/09 by S-K Chin for security* examples with Lockwood Morris.**************************************************)(************ Add the path to where aclfoundationTheory resides.* Then, add the path to HOL's search path.***********)(* Interactive modeval aclPath = "../..";loadPath := aclPath::(!loadPath);*)(************ Load necessary theories***********)(* Interactive modeapp load ["pred_setTheory", "relationTheory", "aclfoundationTheory",          "aclsemanticsTheory", "aclrulesTheory", "oneTheory","acl_infRules"];*)structure IntegrityLevelsScript = structopen HolKernel boolLib Parse bossLibopen pred_setTheory relationTheory aclfoundationTheory;open aclsemanticsTheory aclrulesTheory pairTheory oneTheory acl_infRules;(************ create a new theory***********)val _ = new_theory "IntegrityLevels";(****** BEGINNING OF COMMENTS *******************    Dealing with the composition of integrity levels and subsets   of categories is unnecessary in this simple example(* First a trivial partial order, a product construction on partial   orders, and definition of the superset partial order. *)val one_weakorder_def = Define`one_weakorder (x:one) (y:one) = T`;val one_weakorder_WO = store_thm ("one_weakorder_WO", Term`WeakOrder one_weakorder`,REWRITE_TAC [one_weakorder_def, WeakOrder, reflexive_def, transitive_def,             antisymmetric_def]THEN ONCE_REWRITE_TAC [one] THEN REPEAT GEN_TAC THEN REFL_TAC);val O1_def = Define`O1 = PO one_weakorder`;val repPO_O1 = store_thm ("repPO_O1", Term`repPO O1 = one_weakorder`,REWRITE_TAC [O1_def, po_bij,          EQ_MP (ISPEC (Term`one_weakorder`) WO_repPO) one_weakorder_WO]);(* RPROD, the product of two (Curried) binary relations, turns out to be   already defined in pairTheory; it will be good style to use it. *)(* RPROD_DEF = |- !R1 R2. RPROD R1 R2 = (\(s,t) (u,v). R1 s u /\ R2 t v) *)val RPROD_THM = store_thm ("RPROD_THM", Term`!r s a b:'x#'y. RPROD r s a b = r (FST a) (FST b) /\ s (SND a) (SND b)`,REPEAT GEN_TAC THEN REWRITE_TAC [RPROD_DEF]THEN CONV_TAC (LAND_CONV (ONCE_DEPTH_CONV (REWR_CONV (GSYM PAIR))))THEN CONV_TAC (DEPTH_CONV PAIRED_BETA_CONV) THEN REFL_TAC);(* The following is perhaps a long-winded approach, but it seemsconceivably worth knowing that some individual properties of relationsare preserved by product: *)val refl_prod_refl = store_thm ("refl_prod_refl", Term`!r:'a->'a->bool s:'b->'b->bool.                  reflexive r /\ reflexive s ==> reflexive (RPROD r s)`,REPEAT GEN_TAC THEN REWRITE_TAC [reflexive_def, RPROD_THM]THEN CONV_TAC (DEPTH_CONV PAIRED_BETA_CONV)THEN STRIP_TAC THEN ASM_REWRITE_TAC []);val trans_prod_trans = store_thm ("trans_prod_trans", Term`!r:'a->'a->bool s:'b->'b->bool.               transitive r /\ transitive s ==> transitive (RPROD r s)`,REPEAT GEN_TAC THEN REWRITE_TAC [transitive_def, RPROD_THM]THEN REPEAT STRIP_TAC THEN RES_TAC);val antisym_prod_antisym = store_thm ("antisym_prod_antisym", Term`!r:'a->'a->bool s:'b->'b->bool.     antisymmetric r /\ antisymmetric s ==> antisymmetric (RPROD r s)`,REPEAT GEN_TAC THEN REWRITE_TAC [antisymmetric_def, RPROD_THM]THEN ONCE_REWRITE_TAC [GSYM PAIR] THEN ONCE_REWRITE_TAC [PAIR_EQ]THEN REPEAT STRIP_TACTHEN RES_TAC);val WO_prod_WO = store_thm ("WO_prod_WO", Term`!r:'a->'a->bool s:'b->'b->bool.                   WeakOrder r /\ WeakOrder s ==> WeakOrder (RPROD r s)`,REWRITE_TAC [WeakOrder]THEN REPEAT STRIP_TAC THENL[MATCH_MP_TAC refl_prod_refl, MATCH_MP_TAC antisym_prod_antisym, MATCH_MP_TAC trans_prod_trans] THEN ASM_REWRITE_TAC []);val prod_PO_def = Define `prod_PO (PO1:'a po) (PO2:'b po) = PO (RPROD (repPO PO1) (repPO PO2))`;val repPO_prod_PO = store_thm ("repPO_prod_PO", Term`!po1:'a po po2:'b po. repPO (prod_PO po1 po2) =                                       RPROD (repPO po1) (repPO po2)`,REPEAT GEN_TAC THEN REWRITE_TAC [prod_PO_def, GSYM (CONJUNCT2 po_bij)]THEN MATCH_MP_TAC WO_prod_WOTHEN REWRITE_TAC [WO_repPO, po_bij]);(* Since inclusion is a weak order, we can define, for any type 'a,   the partial order Subset_PO of type ('a -> bool) po. *)val SUBSET_WO = store_thm ("SUBSET_WO", Term     `WeakOrder ($SUBSET:('a -> bool) -> ('a -> bool) -> bool)`,REWRITE_TAC [WeakOrder, reflexive_def, antisymmetric_def,             transitive_def, SUBSET_REFL, SUBSET_ANTISYM, SUBSET_TRANS]);val Subset_PO_def = Define`Subset_PO:('a -> bool) po = PO $SUBSET`;val repPO_Subset_PO = store_thm ("repPO_Subset_PO", Term`repPO Subset_PO = $SUBSET:('a->bool) -> ('a->bool) -> bool`,REWRITE_TAC [Subset_PO_def, po_bij, EQ_MP (ISPEC (Term`$SUBSET:('a->bool) -> ('a->bool) -> bool`) WO_repPO)       SUBSET_WO]);******* END OF COMMENTS ******************************)(*************************************************These are the integrity levels:*************************************************   Prem - Premium*   Reg - Regular** Define the Integrity Classification Labels************************************************)val _ = Hol_datatype    `IClass = Prem | Reg`;(**************************************************** We aim at defining a po which is  an enumerated order* on {Prem, Reg}. The domain of this partial order* is what we may consider "integrity labels" (or do I mean "levels"?);* that is, there is no call for another Hol_datatype.***************************************************)(******** Define the ordering on IClass with Reg at bottom*******)val ICOrder_def = Define `ICOrder y x = (* note args reversed; if-then is as for doms *) if x = Prem then T else if y = Prem then F else T`;(************ Tabulate ICOrder***********)val ICO_table = foldl (uncurry append) []   (map (fn x => map (fn y =>     REWRITE_CONV [ICOrder_def, TypeBase.distinct_of (Type`:IClass`),                          GSYM (TypeBase.distinct_of (Type`:IClass`))]            (Term`ICOrder ^x ^y`))            [``Prem``,``Reg``])	    [``Prem``,``Reg``]);(* ICO_table =    [|- ICOrder Reg Prem ⇔ T, |- ICOrder Reg Reg ⇔ T, |- ICOrder Prem Prem ⇔ T,     |- ICOrder Prem Reg ⇔ F]*)(************** Show that ICOrder is antisymmetric, reflexive, transitive, and* a partial order.*************)val ICOrder_antisymmetric =store_thm  ("ICOrder_antisymmetric",  ``antisymmetric ICOrder``,  REWRITE_TAC [antisymmetric_def] THEN  Cases THEN  Cases THEN  REWRITE_TAC ICO_table);val ICOrder_reflexive =store_thm  ("ICOrder_reflexive",  ``reflexive ICOrder``,  REWRITE_TAC [reflexive_def] THEN  Cases THEN  REWRITE_TAC ICO_table);val ICOrder_transitive =store_thm  ("ICOrder_transitive",  ``transitive ICOrder``,  REWRITE_TAC [transitive_def] THEN  Cases THEN  Cases THEN  Cases THEN REWRITE_TAC ICO_table);val ICOrder_WO =store_thm   ("ICOrder_WO",    ``WeakOrder ICOrder``,   REWRITE_TAC [ICOrder_antisymmetric,                ICOrder_reflexive, ICOrder_transitive,WeakOrder]);(*************** Define classification level po***************)val ICOrder_PO_def =    Define `ICOrder_PO = PO ICOrder`;val repPO_ICOrder_PO = store_thm ("repPO_ICOrder_PO", Term`repPO ICOrder_PO = ICOrder`,REWRITE_TAC [ICOrder_PO_def, po_bij, EQ_MP (ISPEC (Term`ICOrder`) WO_repPO) ICOrder_WO]);(*************** Partial order properties on IClass for any partial ordering on IClass***************) val IClass_PO_reflexive =   store_thm( "IClass_PO_reflexive",   Term`!(l:('pName,IClass)IntLevel)   (M:('propVar,'Worlds,'pName,IClass,'Sec)Kripke)    (Oi:IClass po)(Os:'Sec po).   (M,Oi,Os) sat (l domi l):('propVar,'pName,IClass,'Sec)Form`,   REWRITE_TAC [domi_reflexive]);val IClass_PO_transitive =   store_thm(   "IClass_PO_transitive",   Term`!(l1:('pName,IClass)IntLevel)         (l2:('pName,IClass)IntLevel)         (l3:('pName,IClass)IntLevel)         (M:('propVar,'Worlds,'pName,IClass,'Sec)Kripke)         (Oi:IClass po)(Os:'Sec po).         (M,Oi,Os) sat (l1 domi l2):('propVar,'pName,IClass,'Sec)Form ==>	 (M,Oi,Os) sat (l2 domi l3):('propVar,'pName,IClass,'Sec)Form ==>	 (M,Oi,Os) sat (l1 domi l3):('propVar,'pName,IClass,'Sec)Form`,   REWRITE_TAC [domi_transitive]);val IClass_PO_antisymmetric =   store_thm(   "IClass_PO_antisymmetric",   Term`!(l1:('pName,IClass)IntLevel)         (l2:('pName,IClass)IntLevel)         (M:('propVar,'Worlds,'pName,IClass,'Sec)Kripke)         (Oi:IClass po)(Os:'Sec po).         (M,Oi,Os) sat (l1 domi l2):('propVar,'pName,IClass,'Sec)Form ==>	 (M,Oi,Os) sat (l2 domi l1):('propVar,'pName,IClass,'Sec)Form ==>	 (M,Oi,Os) sat (l1 eqi l2):('propVar,'pName,IClass,'Sec)Form`,   REWRITE_TAC [domi_antisymmetric]);(******************** REWRITE-ing with the theorem ICOrder_simp (or with the theorem list ICO_table if you prefer) will evaluate an application of ICOrder to two constants to a truth value. *********************)val ICOrder_simp = save_thm ("ICOrder_simp", CONJ repPO_ICOrder_PO (CONJ ICOrder_def                        (CONJ (TypeBase.distinct_of (Type`:IClass`))                         (GSYM (TypeBase.distinct_of (Type`:IClass`))))));(******************** Specific ordering given ICOrder_PO********************)val Prem_domi_Reg =   store_thm   ("Prem_domi_Reg",   Term`((M:('propVar,'Worlds,'pName,IClass,'Sec)Kripke),         ICOrder_PO,Os:'Sec po) sat ((iLab Prem) domi (iLab Reg)):        ('propVar,'pName,IClass,'Sec)Form`,   REWRITE_TAC[sat_def,domi_def,Lifn_def,ICOrder_simp]);val _ = export_theory ();val _ = print_theory "IntegrityLevels";end (* structure *)