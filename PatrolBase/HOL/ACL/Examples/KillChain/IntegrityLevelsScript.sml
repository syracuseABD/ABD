(**************************************************** IntegrityLevels: Created by S-K Chin, 11/7/10* Based on SecurityLevels created on 3/1/09 by S-K Chin for security* examples with Lockwood Morris.**************************************************)(************ Add the path to where aclfoundationTheory resides.* Then, add the path to HOL's search path.***********)(* Interactive modeval aclPath = "/home/chin/Documents/HOL/ACL";loadPath := aclPath::(!loadPath);(* Disable Pretty-Printing *)set_trace "Unicode" 0;*)(************ Load necessary theories***********)(* Interactive modeapp load ["pred_setTheory", "relationTheory", "aclfoundationTheory",          "aclsemanticsTheory", "aclrulesTheory", "oneTheory"];*)structure IntegrityLevelsScript = structopen HolKernel boolLib Parse bossLibopen pred_setTheory relationTheory aclfoundationTheory;open aclsemanticsTheory aclrulesTheory pairTheory oneTheory;(************ create a new theory***********)val _ = new_theory "IntegrityLevels";(* First a trivial partial order, a product construction on partial   orders, and definition of the superset partial order. *)val one_weakorder_def = Define`one_weakorder (x:one) (y:one) = T`;val one_weakorder_WO = store_thm ("one_weakorder_WO", Term`WeakOrder one_weakorder`,REWRITE_TAC [one_weakorder_def, WeakOrder, reflexive_def, transitive_def,             antisymmetric_def]THEN ONCE_REWRITE_TAC [one] THEN REPEAT GEN_TAC THEN REFL_TAC);val O1_def = Define`O1 = PO one_weakorder`;val repPO_O1 = store_thm ("repPO_O1", Term`repPO O1 = one_weakorder`,REWRITE_TAC [O1_def, po_bij,          EQ_MP (ISPEC (Term`one_weakorder`) WO_repPO) one_weakorder_WO]);(* RPROD, the product of two (Curried) binary relations, turns out to be   already defined in pairTheory; it will be good style to use it. *)(* RPROD_DEF = |- !R1 R2. RPROD R1 R2 = (\(s,t) (u,v). R1 s u /\ R2 t v) *)val RPROD_THM = store_thm ("RPROD_THM", Term`!r s a b:'x#'y. RPROD r s a b = r (FST a) (FST b) /\ s (SND a) (SND b)`,REPEAT GEN_TAC THEN REWRITE_TAC [RPROD_DEF]THEN CONV_TAC (LAND_CONV (ONCE_DEPTH_CONV (REWR_CONV (GSYM PAIR))))THEN CONV_TAC (DEPTH_CONV PAIRED_BETA_CONV) THEN REFL_TAC);(* The following is perhaps a long-winded approach, but it seemsconceivably worth knowing that some individual properties of relationsare preserved by product: *)val refl_prod_refl = store_thm ("refl_prod_refl", Term`!r:'a->'a->bool s:'b->'b->bool.                  reflexive r /\ reflexive s ==> reflexive (RPROD r s)`,REPEAT GEN_TAC THEN REWRITE_TAC [reflexive_def, RPROD_THM]THEN CONV_TAC (DEPTH_CONV PAIRED_BETA_CONV)THEN STRIP_TAC THEN ASM_REWRITE_TAC []);val trans_prod_trans = store_thm ("trans_prod_trans", Term`!r:'a->'a->bool s:'b->'b->bool.               transitive r /\ transitive s ==> transitive (RPROD r s)`,REPEAT GEN_TAC THEN REWRITE_TAC [transitive_def, RPROD_THM]THEN REPEAT STRIP_TAC THEN RES_TAC);val antisym_prod_antisym = store_thm ("antisym_prod_antisym", Term`!r:'a->'a->bool s:'b->'b->bool.     antisymmetric r /\ antisymmetric s ==> antisymmetric (RPROD r s)`,REPEAT GEN_TAC THEN REWRITE_TAC [antisymmetric_def, RPROD_THM]THEN ONCE_REWRITE_TAC [GSYM PAIR] THEN ONCE_REWRITE_TAC [PAIR_EQ]THEN REPEAT STRIP_TACTHEN RES_TAC);val WO_prod_WO = store_thm ("WO_prod_WO", Term`!r:'a->'a->bool s:'b->'b->bool.                   WeakOrder r /\ WeakOrder s ==> WeakOrder (RPROD r s)`,REWRITE_TAC [WeakOrder]THEN REPEAT STRIP_TAC THENL[MATCH_MP_TAC refl_prod_refl, MATCH_MP_TAC antisym_prod_antisym, MATCH_MP_TAC trans_prod_trans] THEN ASM_REWRITE_TAC []);val prod_PO_def = Define `prod_PO (PO1:'a po) (PO2:'b po) = PO (RPROD (repPO PO1) (repPO PO2))`;val repPO_prod_PO = store_thm ("repPO_prod_PO", Term`!po1:'a po po2:'b po. repPO (prod_PO po1 po2) =                                       RPROD (repPO po1) (repPO po2)`,REPEAT GEN_TAC THEN REWRITE_TAC [prod_PO_def, GSYM (CONJUNCT2 po_bij)]THEN MATCH_MP_TAC WO_prod_WOTHEN REWRITE_TAC [WO_repPO, po_bij]);(* Since inclusion is a weak order, we can define, for any type 'a,   the partial order Subset_PO of type ('a -> bool) po. *)val SUBSET_WO = store_thm ("SUBSET_WO", Term     `WeakOrder ($SUBSET:('a -> bool) -> ('a -> bool) -> bool)`,REWRITE_TAC [WeakOrder, reflexive_def, antisymmetric_def,             transitive_def, SUBSET_REFL, SUBSET_ANTISYM, SUBSET_TRANS]);val Subset_PO_def = Define`Subset_PO:('a -> bool) po = PO $SUBSET`;val repPO_Subset_PO = store_thm ("repPO_Subset_PO", Term`repPO Subset_PO = $SUBSET:('a->bool) -> ('a->bool) -> bool`,REWRITE_TAC [Subset_PO_def, po_bij, EQ_MP (ISPEC (Term`$SUBSET:('a->bool) -> ('a->bool) -> bool`) WO_repPO)       SUBSET_WO]);(*************************************************These are the integrity levels:*************************************************   Sec - Security level*    Op - Operational level** The Sec level is for security officers to establish trust and* place certificates in the system. The Op level is for operators* who can write * Define the Integrity Classification Labels************************************************)val _ = Hol_datatype    `IClass = Sec | Op`;(************************************************* We have the following categories:*   Cert - Certifications*    Msg - Messages************************************************)val _ = Hol_datatype    `Categories = Cert | Msg`;(**************************************************** We aim at defining a po which is the product of an enumerated order* on {Sec, Op} with the Subset* partial order on (Categories set). The domain of this partial order* is what we may consider "integrity labels" (or do I mean "levels"?);* that is, there is no call for another Hol_datatype.***************************************************)(******* Define the accessor functions*****)(* IClass retrieves the security classification from a label *)val getIClass_def =  Define `getIClass = (FST:IClass # Categories set -> IClass)`;(* ICat retrieves the set of categories from a label *)val getICat_def =  Define `getICat = (SND:IClass # Categories set -> Categories set)`;(******** Properties of accessor functions are those of FST and SND*******)(******** Define the ordering on IClass with Op at bottom*******)val ICOrder_def = Define `ICOrder y x = (* note args reversed; if-then is as for doms *) if x = Sec then T else if y = Sec then F else T`;(************ Tabulate ICOrder***********)val ICO_table = foldl (uncurry append) []   (map (fn x => map (fn y =>     REWRITE_CONV [ICOrder_def, TypeBase.distinct_of (Type`:IClass`),                          GSYM (TypeBase.distinct_of (Type`:IClass`))]            (Term`ICOrder ^x ^y`))            [``Sec``,``Op``])	    [``Sec``,``Op``]);(* ICO_table =    [|- ICOrder Op Sec ⇔ T, |- ICOrder Op Op ⇔ T, |- ICOrder Sec Sec ⇔ T,     |- ICOrder Sec Op ⇔ F]*)(************** Show that ICOrder is antisymmetric, reflexive, transitive, and* a partial order.*************)val ICOrder_antisymmetric =store_thm  ("ICOrder_antisymmetric",  ``antisymmetric ICOrder``,  REWRITE_TAC [antisymmetric_def] THEN  Cases THEN  Cases THEN  REWRITE_TAC ICO_table);val ICOrder_reflexive =store_thm  ("ICOrder_reflexive",  ``reflexive ICOrder``,  REWRITE_TAC [reflexive_def] THEN  Cases THEN  REWRITE_TAC ICO_table);val ICOrder_transitive =store_thm  ("ICOrder_transitive",  ``transitive ICOrder``,  REWRITE_TAC [transitive_def] THEN  Cases THEN  Cases THEN  Cases THEN REWRITE_TAC ICO_table);val ICOrder_WO =store_thm   ("ICOrder_WO",    ``WeakOrder ICOrder``,   REWRITE_TAC [ICOrder_antisymmetric,                ICOrder_reflexive, ICOrder_transitive,WeakOrder]);(**************** Define classification level po***************)val IClass_PO_def =    Define `IClass_PO = PO ICOrder`;val repPO_IClass_PO = store_thm ("repPO_IClass_PO", Term`repPO IClass_PO = ICOrder`,REWRITE_TAC [IClass_PO_def, po_bij, EQ_MP (ISPEC (Term`ICOrder`) WO_repPO) ICOrder_WO]);(*************** Gather up one big theorem for SL_DOMS or IL_DOMI to use**************)val ICOrder_simp = save_thm ("ICOrder_simp", CONJ repPO_IClass_PO (CONJ ICOrder_def                        (CONJ (TypeBase.distinct_of (Type`:IClass`))                         (GSYM (TypeBase.distinct_of (Type`:IClass`))))));(* REWRITE-ing with the theorem ICOrder_simp (or with the theorem list   ICO_table if you prefer) will evaluate an application of ICOrder   to two constants to a truth value. *)(******** Define OInt*******)val OInt_def = Define `OInt = prod_PO IClass_PO (Subset_PO:(Categories -> bool) po)`;(******* Properties of OInt******)val repPO_OInt =store_thm ("repPO_OInt",Term`!il1 il2. repPO OInt il1 il2 = ICOrder (getIClass il1) (getIClass il2) /\                                (getICat il1) SUBSET (getICat il2)`,REWRITE_TAC [getIClass_def, getICat_def, OInt_def, repPO_prod_PO,             repPO_Subset_PO, repPO_IClass_PO, RPROD_THM]);val _ = export_theory ();val _ = print_theory "IntegrityLevels";end (* structure *)